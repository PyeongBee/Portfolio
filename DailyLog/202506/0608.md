2025년 6월 8일 일기
오늘은 Spring Boot 프로젝트에 Flyway를 도입하는 과정에서 여러 가지 흥미로운 문제들을 해결하며 많은 것을 배운 하루였다. 나의 초기 예측과 달리, 직접 시도한 해결책들이 주효했던 부분에서 큰 깨달음을 얻었다.

처음에는 Flyway를 통해 데이터베이스 버전 관리를 v1.0.0 같은 형태로 하고 싶었다. Flyway가 기본적으로 숫자 기반의 버전을 사용한다는 것을 알고, V1_0_0\_\_initial_schema.sql처럼 파일명을 지정하고 SQL 파일 내부에 주석으로 실제 버전을 명시하는 방법을 익혔다. 이 방식이 가장 자연스럽고 Flyway의 기본 동작을 해치지 않는다는 점이 마음에 들었다.

하지만 바로 난관에 봉착했다. Gradle 빌드 시 Could not find org.flywaydb:flyway-core:12.3이라는 오류가 발생한 것이다. 처음에는 당황했지만, 알고 보니 Flyway의 버전 번호를 잘못 기재한 것이 문제였다. 12.3과 같은 버전은 존재하지 않았고, 최신 안정 버전인 10.x.x대로 수정하니 바로 해결되었다. 작은 오타 하나가 빌드를 멈출 수 있다는 것을 다시 한번 깨달았다.

다음으로는 FlywaySqlScriptException과 java.sql.SQLException이 발생했다. SQL 스크립트 내부의 문제라는 것을 짐작했고, 스크립트를 꼼꼼히 살펴보니 DECIMAL 타입 컬럼에 -와 같은 문자열을 삽입하려던 것이 원인이었다. 데이터 타입에 맞는 값을 넣어주거나, NULL을 허용하도록 DDL을 변경해야 한다는 것을 배웠다. 사소한 데이터 타입 불일치가 큰 오류로 이어질 수 있음을 다시금 확인했다.

가장 골치 아팠던 문제는 Table 'EXCHANGE.user' doesn't exist 오류였다. 분명 USER 테이블이 존재하는데도 user를 찾지 못하는 것이 의아했다. MySQL의 lower_case_table_names 설정 문제일 것이라는 예측이 가장 강력했지만, 나는 좀 더 근본적인 방법을 택했다. Flyway 마이그레이션 스크립트에서 CREATE TABLE USER와 같이 대문자로 명시했던 모든 테이블 이름을 CREATE TABLE user처럼 소문자로 통일한 것이다. JPA가 소문자 테이블을 더 선호한다는 힌트를 얻어 실행에 옮겼는데, 이 방법이 주효했다! 이제 데이터베이스에도 소문자로 테이블이 생성되고, JPA 또한 이 소문자 테이블을 문제없이 찾아내면서 오류가 말끔히 사라졌다. 데이터베이스와 애플리케이션 간의 명명 규칙을 일치시키는 것이 얼마나 중요한지 다시 한번 느꼈다.

그리고 오늘 가장 마지막에 발생한 JWT expired 오류는 정말 예상치 못한 지점에서 해결책을 찾았다. 처음에는 서버의 시스템 시간 문제일까, 아니면 JWT 생성 로직의 문제일까를 의심하며 깊이 파고들었다. 하지만 System.currentTimeMillis()의 출력값이 정상이고 expiration 설정도 올바르다는 것을 디버깅으로 확인하면서 점점 미궁으로 빠지는 듯했다. 그러다 문득, 새로 발급받은 JWT 쿠키가 클라이언트(브라우저)에 제대로 저장되지 않는다는 사실을 발견했다. 개발자 도구의 Application 탭에 들어가 쿠키 목록을 확인해보니, 로그인 성공 시 Set-Cookie 헤더로 쿠키가 넘어오긴 하는데, 정작 브라우저에는 저장되지 않고 있었다. 이전에 withCredentials: true 옵션을 선택적으로 주지 않아도 된다고 들어서 생략했었는데, 이게 문제의 원인이었다! 프론트엔드 로그인 요청에 withCredentials: true 옵션을 추가해주자마자, 새로운 JWT 쿠키가 브라우저에 정상적으로 세팅되기 시작했고, 이후 모든 요청에서 유효한 토큰이 전송되면서 JWT expired 오류가 마법처럼 사라졌다. 서버 코드가 아닌, 프론트엔드와 백엔드 간의 통신 설정 문제였다는 점에서 큰 충격을 받았다. 단순한 옵션 하나가 전체 인증 흐름을 좌우할 수 있다는 것을 깨달으며, 프론트엔드와 백엔드의 연동 디버깅의 중요성을 다시 한번 상기시켰다.

마지막으로 JWT 기반 로그인에서 로그아웃을 어떻게 구현해야 하는지에 대한 고민도 해결되었다. 단순히 클라이언트에서 쿠키를 제거하는 것이 기본이지만, 강제 로그아웃이나 토큰 탈취에 대비하기 위해서는 서버에 블랙리스트를 두거나 Refresh Token 전략을 사용하는 등 추가적인 보안 강화가 필요하다는 점을 배웠다. JWT의 stateless 특성을 이해하고 상황에 맞는 로그아웃 전략을 세우는 것이 중요함을 알았다.

오늘 하루는 Spring Boot, Flyway, JPA, MySQL, 그리고 JWT에 이르는 넓은 범위의 기술 스택에서 발생할 수 있는 실제적인 문제들을 경험하고 해결하며 깊이 있는 지식을 쌓을 수 있었다. 특히 직접적인 코딩 외에 데이터베이스 설정, 그리고 프론트엔드와의 통신 설정까지 폭넓게 고려해야 한다는 것을 배운 보람찬 하루였다.
